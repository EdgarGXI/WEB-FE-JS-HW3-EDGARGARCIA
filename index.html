<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Asynchronous Concepts</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <h1>JavaScript Asynchronous Concepts</h1>

        <section id="async">
            <h2>1. JavaScript Async</h2>
            <p>
                Asynchronous programming in JavaScript allows code to execute without blocking the main thread. 
                This example simulates loading different parts of a webpage asynchronously.
            </p>
            <div class="code-box">
                <pre><code>
console.log("Start loading page");
setTimeout(() => console.log("Images loaded"), 2000);
setTimeout(() => console.log("Content loaded"), 1000);
console.log("End of script");
                </code></pre>
            </div>
            <div class="demo-box">
                <button id="asyncBtn" class="btn">Load Page</button>
                <div id="asyncOutput" class="output">
                    <div id="pageStructure" style="display: none;">Page Structure</div>
                    <div id="pageContent" style="display: none;">Page Content</div>
                    <div id="pageImages" style="display: none;">Images</div>
                </div>
            </div>
        </section>

        <section id="callback">
            <h2>2. Callback</h2>
            <p>
                Callbacks are functions passed as arguments to other functions, allowing you to execute code after an asynchronous operation completes.
                This example simulates a database query using callbacks.
            </p>
            <div class="code-box">
                <pre><code>
function queryDatabase(query, callback) {
    setTimeout(() => {
        const result = { id: 1, name: "John Doe" };
        callback(result);
    }, 2000);
}

queryDatabase("SELECT * FROM users", (result) => {
    console.log("User:", result.name);
});
                </code></pre>
            </div>
            <div class="demo-box">
                <button id="callbackBtn" class="btn">Query Database</button>
                <div id="callbackOutput" class="output"></div>
            </div>
        </section>

        <section id="promise">
            <h2>3. Promise</h2>
            <p>
                Promises provide a cleaner way to handle asynchronous operations. This example simulates fetching weather data using a Promise.
            </p>
            <div class="code-box">
                <pre><code>
function fetchWeather() {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            const weather = { temp: 72, condition: "Sunny" };
            resolve(weather);
        }, 2000);
    });
}

fetchWeather()
    .then(weather => console.log(`Temperature: ${weather.temp}Â°F, Condition: ${weather.condition}`))
    .catch(error => console.error("Failed to fetch weather"));
                </code></pre>
            </div>
            <div class="demo-box">
                <button id="promiseBtn" class="btn">Fetch Weather</button>
                <div id="promiseOutput" class="output"></div>
            </div>
        </section>

        <section id="async-await">
            <h2>4. Async/Await</h2>
            <p>
                Async/Await makes asynchronous code look and behave more like synchronous code. This example simulates a multi-step process of ordering a product.
            </p>
            <div class="code-box">
                <pre><code>
async function orderProduct(productId) {
    try {
        const product = await fetchProduct(productId);
        const order = await createOrder(product);
        const shipment = await shipOrder(order);
        return `Order ${shipment.id} shipped to ${shipment.address}`;
    } catch (error) {
        return `Error: ${error.message}`;
    }
}

orderProduct(123).then(result => console.log(result));
                </code></pre>
            </div>
            <div class="demo-box">
                <button id="asyncAwaitBtn" class="btn">Order Product</button>
                <div id="asyncAwaitOutput" class="output"></div>
            </div>
        </section>

        <section id="event-loop">
            <h2>5. Event Loop</h2>
            <p>
                The Event Loop manages the execution of code, handling asynchronous callbacks, and maintaining the order of operations.
                This example visualizes how different types of tasks are processed.
            </p>
            <div class="code-box">
                <pre><code>
console.log("1. Synchronous task");
setTimeout(() => console.log("4. Timer callback"), 0);
Promise.resolve().then(() => console.log("3. Microtask"));
console.log("2. Synchronous task");
                </code></pre>
            </div>
            <div class="demo-box">
                <button id="eventLoopBtn" class="btn">Run Event Loop</button>
                <div id="eventLoopOutput" class="output"></div>
                <div id="eventLoopVisual" class="event-loop-visual">
                    <div class="task-queue">
                        <h4>Task Queue</h4>
                        <div id="taskQueue"></div>
                    </div>
                    <div class="microtask-queue">
                        <h4>Microtask Queue</h4>
                        <div id="microtaskQueue"></div>
                    </div>
                    <div class="call-stack">
                        <h4>Call Stack</h4>
                        <div id="callStack"></div>
                    </div>
                </div>
            </div>
        </section>
    </div>

    <script src="script.js"></script>
</body>
</html>